### 工作中遇到的几种算法解析



####  雪花算法

> 雪花算法(**snowflake**),是一种生成分布是ID的一种算法,





#### SHA-1

> Git commit object **名称**的生产算法,



基本运算步骤

1. 获取输入消息的ASCII转为二进制

   ```mermaid
   graph LR
   
   A[abc] -->|转换| B(ACSII)
   B-->|转换| C(二进制)
   ```

2. 补位对转换后的位字符串进行补位操作

   

   > Sha-1算法标准规定，必须对消息摘要进行补位操作，即将输入的数据进行填充，使得数据长度对512求余的结果为448，填充比特位的最高位补一个1，其余的位补0，如果在补位之前已经满足对512取模余数为448，也要进行补位，在其后补一位1即可。总之，补位是至少补一位，最多补512位，

   

   - 以“abc”为例，其补位过程如下：

   初始的信息摘要：01100001 01100010 01100011

   第一步补位：    01100001 01100010 01100011 1

   补位最后一位：  01100001 01100010 01100011 10.......0(后面补了423个0)

   而后我们将补位操作后的信息摘要转换为十六进制，如下所示：

   

   61626380 00000000 00000000 00000000

   00000000 00000000 00000000 00000000

   00000000 00000000 00000000 00000000

   00000000 00000000

3. 附加长度值

   > 在信息摘要后面附加64bit的信息，用来表示原始信息摘要的长度，在这步操作之后，信息报文便是512bit的倍数。通常来说用一个64位的数据表示原始消息的长度，如果消息长度不大于2^64，那么前32bit就为0，在进行附加长度值操作后，其“abc”数据报文即变成如下形式：

   61626380 00000000 00000000 00000000

   00000000 00000000 00000000 00000000

   00000000 00000000 00000000 00000000

   00000000 00000000 00000000 00000018

   因为“abc”占3个字节，即24位 ，换算为十六进制即为0x18。
   
4. 
    初始化缓存

   > 一个160位MD缓冲区用以保存中间和最终散列函数的结果。它可以表示为5个32位的寄存器(H0,H1,H2,H3,H4)。初始化为：

   H0 = 0x67452301

   H1 = 0xEFCDAB89

   H2 = 0x98BADCFE

   H3 = 0x10325476

   H4 = 0xC3D2E1F0

   如果大家对MD-5不陌生的话，会发现一个重要的现象，其前四个与MD-5一样，但不同之处为存储为big-endien format.

 5. 计算消息摘要

    > 在计算报文之前我们还要做一些基本的工作，就是在我们计算过程中要用到的方法，或定义。
    >
    > (1)、循环左移操作符Sn(x),x是一个字，也就是32bit大小的变量，n是一个整数且0<=n<=32。Sn(X) = (X<<n)OR(X>>32-n)
    >
    >  (2)、在程序中所要用到的常量，这一系列常量字k(0)、k(1)、...k(79)，将其以十六进制表示如下：
    >
    >  Kt = 0x5A827999  (0 <= t <= 19)
    >
    >  Kt = 0x6ED9EBA1 (20 <= t <= 39)
    >
    >  Kt = 0x8F1BBCDC (40 <= t <= 59)
    >
    >  Kt = 0xCA62C1D6 (60 <= t <= 79)

​      (3)、所要用到的一系列函数

   

    Ft(b,c,d)  ((b&c)|((~b)&d))    (0 <= t <= 19)

   



    Ft(b,c,d) (b^c^d)             (20 <= t <= 39)

   



    Ft(b,c,d) ((b&c)|(b&d)|(c&d))  (40 <= t <= 59)

   



    Ft(b,c,d) (b^c^d)               (60 <= t <= 79)

   



   (4)、计算

   

   计算需要一个缓冲区，由5个32位的字组成，还需要一个80个32位字的缓冲区。第一个5个字的缓冲区被标识为A，B，C，D，E。80个字的缓冲区被标识为W0, W1,..., W79

   

   另外还需要一个一个字的TEMP缓冲区。

   

   为了产生消息摘要，在第4部分中定义的16个字的数据块M1, M2,..., Mn

   

   会依次进行处理，处理每个数据块Mi 包含80个步骤。

   

   现在开始处理M1, M2, ... , Mn。为了处理 Mi,需要进行下面的步骤

   

   (1). 将 Mi 分成 16 个字 W0, W1, ... , W15,  W0 是最左边的字

   

   (2). 对于 t = 16 到 79 令 Wt = S1(Wt-3 XOR Wt-8 XOR Wt- 14 XOR Wt-16).

   

   (3). 令 A = H0, B = H1, C = H2, D = H3, E = H4.

   

   (4) 对于 t = 0 到 79，执行下面的循环

   

   TEMP = S5(A) + ft(B,C,D) + E + Wt + Kt;

   

   E = D; D = C; C = S30(B); B = A; A = TEMP;

   

   (5). 令 H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E. 

   

   在处理完所有的 Mn, 后，消息摘要是一个160位的字符串，以下面的顺序标识

   

   H0 H1 H2 H3 H4.

#### DMS算法

> 很SHA-1一样是一种常用的**hash运算**算法



#### PCA算法

> PCA算法 -- 主成分分析算法最典型的场景就是图像识别中的人脸器官识别。



#### 





